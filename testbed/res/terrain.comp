#version 450 core

// If these are passed from the CPU side
uniform vec2 terrainSize;
uniform float heightScale;


//workgroup size 16x16
layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0) buffer TerrainData {
    vec4 terrainData[];
};

// Pseudo-random hash function
/*
float hash(vec2 p) {
    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));
    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );
}

*/
/*
// Smooth interpolation
float smoothNoise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    // Smooth Interpolation Curve
    vec2 u = f*f*(3.0-2.0*f);

    return mix( mix( hash( i + vec2(0.0,0.0) ),
    hash( i + vec2(1.0,0.0) ), u.x),
    mix( hash( i + vec2(0.0,1.0) ),
    hash( i + vec2(1.0,1.0) ), u.x), u.y);
}

// Fractal Brownian Motion (fBm) for more natural noise
float perlinNoise(vec2 p) {
    float f = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;

    // Octaves for more detailed noise
    for (int i = 0; i < 6; i++) {
        f += amplitude * smoothNoise(frequency * p);
        amplitude *= 0.5;
        frequency *= 2.0;
    }

    return f;
}

*/

float perlinNoise(vec2 p) {
    // Simplex noise or Perlin noise function can be implemented here
    // For simplicity, we will use a placeholder value
    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() 
{
    // Get the local ID of the current workgroup
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);

    if (gid.x >= terrainSize.x || gid.y >= terrainSize.y)
    {
        return;  // Don't process out-of-bounds workgroups
    }

    // Calculate the position of this terrain cell
    vec2 terrainPos = vec2(gid.x, gid.y);

    // Generate terrain height using Perlin Noise (or other noise functions)
    float noiseValue = perlinNoise(terrainPos * 0.1); // Adjust the scaling factor as needed

    // Apply the height scale
    float height = noiseValue * heightScale;

    // Store the calculated height in the terrainData array
    terrainData[gid.y * int(terrainSize.x) + gid.x] = vec4(terrainPos, height, 1.0);

}